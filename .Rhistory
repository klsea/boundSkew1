# baseline - only degree of skew
b1 <- glmer(accept ~ deg_skew + (1 + Age | ID), data = d1, family = binomial(link = logit), nAGQ = 1,
control=glmerControl(optimizer='bobyqa'))
##follow-up t-tests
d2 <- summarySE(d1, 'accept', groupvars = c('ID', 'deg_skew'))
d3 <- spread(d2[,c(1,2,4)], 'deg_skew', 'accept')
b1_follow <- pairedttable(d3, colnames(d3[2:5]), 1)
View(b1_follow)
t <- t.test(d3$Symmetric, d3$Moderate)
t$parameter
t$estimate
t$statistic
t$parameter
output=1
dt=1
ifelse(output == 1, return(dt), ifelse(output==2, return(d2), return(d3)))
pairedttable <- function(data, var.names, output){
# data is a data frame in wide format with only an ID column in front of columns of interest
# var.names is a vector with the names of the columns you want to compare
# output is your desired output
dt <- matrix(nrow = length(var.names), ncol = length(var.names)-1)
d2 <- matrix(nrow = length(var.names), ncol = length(var.names)-1)
d3 <- matrix(nrow = length(var.names), ncol = length(var.names)-1)
count = 0
for (l1 in 1:(length(var.names)-1)){
print(l1)
var1 = var.names[l1]
print(var1)
for (l2 in (l1+1):length(var.names)) {
print(l2)
var2 = var.names[l2]
print(var2)
t <- t.test(data[,l1+1], data[,l2+1], paired = TRUE, na.action=na.omit)
print(t)
dt[l1, l2-1] <- paste0(round(t$statistic,2), '[', round(t$conf.int[1],2), ',', round(t$conf.int[2],2), ']')
d2[l1, l2-1] <- round(t$p.value, 4)
d3[l1, l2-1] <- t$parameter
count = count+1
}
}
criticalp = 0.05/count
row.names(dt) <- var.names
colnames(dt) <- var.names[2:length(var.names)]
row.names(d2) <- var.names
colnames(d2) <- var.names[2:length(var.names)]
row.names(d3) <- var.names
colnames(d3) <- var.names[2:length(var.names)]
ifelse(output == 1, return(dt), ifelse(output==2, return(d2), return(d3)))
}
# load required packages
library(here)
library(lme4)
library(gdata)
library(tidyr)
# load source functions
source(here::here('scr', 'isolate_skew.R'))
source(here::here('scr', 'clean_skew.R'))
source(here::here('scr', 'SummarySE.R'))
source(here::here('scr', 'pairedttable.R'))
# load data
dt <- read.csv(here::here("data", "bound_skew1_data.csv"))
# separate skew
d0 <- isolate_skew(dt,c(1,2),10:69)
d1 <- clean_skew(d0)
# recode response to acceptance
d1$accept <- d1$response - 1
# reorder deg_skew factor
d1$deg_skew <- factor(d1$deg_skew, levels = c('Symmetric', 'Weak', 'Moderate', 'Strong'))
# reorder valence factor
d1$valence <- factor(d1$valence, levels = c('neutral', 'gain', 'loss'))
# make magnitude a factor
d1$magnitude <- factor(d1$magnitude, levels = c('0', '0.5', '5'))
# scale and center age
d1$Age <- scale(d1$Age)
# make interaction term
d1$magval <- interaction(d1$valence, d1$magnitude)
d1$magval <- drop.levels(d1$magval)
d1$magval <- factor(d1$magval, levels = c('neutral.0', 'loss.5', 'loss.0.5', 'gain.0.5', 'gain.5'))
# baseline - only degree of skew
b1 <- glmer(accept ~ deg_skew + (1 + Age | ID), data = d1, family = binomial(link = logit), nAGQ = 1,
control=glmerControl(optimizer='bobyqa'))
summary(b1, correlation = FALSE)
## boundary fit - remove age from random effects
b1.1 <- glmer(accept ~ deg_skew + (1 | ID), data = d1, family = binomial(link = logit), nAGQ = 1,
control=glmerControl(optimizer='bobyqa'))
summary(b1.1, correlation = FALSE)
saveRDS(b1.1, here::here('output', 'baseline.RDS'))
##follow-up t-tests
d2 <- summarySE(d1, 'accept', groupvars = c('ID', 'deg_skew'))
d3 <- spread(d2[,c(1,2,4)], 'deg_skew', 'accept')
b1_follow <- pairedttable(d3, colnames(d3[2:5]), 1)
pairedttable(d3, colnames(d3[2:5]), 3)
clear
data = d3
var.names(d3[2:5])
var.names= colnames(d3[2:5])
# data is a data frame in wide format with only an ID column in front of columns of interest
# var.names is a vector with the names of the columns you want to compare
# output is your desired output
dt <- matrix(nrow = length(var.names), ncol = length(var.names)-1)
d2 <- matrix(nrow = length(var.names), ncol = length(var.names)-1)
d3 <- matrix(nrow = length(var.names), ncol = length(var.names)-1)
count = 0
for (l1 in 1:(length(var.names)-1)){
print(l1)
var1 = var.names[l1]
print(var1)
for (l2 in (l1+1):length(var.names)) {
print(l2)
var2 = var.names[l2]
print(var2)
t <- t.test(data[,l1+1], data[,l2+1], paired = TRUE, na.action=na.omit)
print(t)
dt[l1, l2-1] <- paste0(round(t$statistic,2), '[', round(t$conf.int[1],2), ',', round(t$conf.int[2],2), ']')
d2[l1, l2-1] <- round(t$p.value, 4)
d3[l1, l2-1] <- t$parameter
count = count+1
}
}
#criticalp = 0.05/count
row.names(dt) <- var.names
colnames(dt) <- var.names[2:length(var.names)]
row.names(d2) <- var.names
colnames(d2) <- var.names[2:length(var.names)]
row.names(d3) <- var.names
colnames(d3) <- var.names[2:length(var.names)]
dt
d2
d3
d1 <- c(dt, d2, d3)
d1
d1 <- list(dt, d2, d3)
View(d1)
d1 <- list('t values and CI' = dt, 'p values' = d2, 'df' = d3)
View(d1)
pairedttable <- function(data, var.names){
# data is a data frame in wide format with only an ID column in front of columns of interest
# var.names is a vector with the names of the columns you want to compare
# output is your desired output
dt <- matrix(nrow = length(var.names), ncol = length(var.names)-1)
d2 <- matrix(nrow = length(var.names), ncol = length(var.names)-1)
d3 <- matrix(nrow = length(var.names), ncol = length(var.names)-1)
count = 0
for (l1 in 1:(length(var.names)-1)){
print(l1)
var1 = var.names[l1]
print(var1)
for (l2 in (l1+1):length(var.names)) {
print(l2)
var2 = var.names[l2]
print(var2)
t <- t.test(data[,l1+1], data[,l2+1], paired = TRUE, na.action=na.omit)
print(t)
dt[l1, l2-1] <- round(t$statistic,2)
d1[l1, l2-1] <- paste0('[', round(t$conf.int[1],2), ',', round(t$conf.int[2],2), ']')
d2[l1, l2-1] <- round(t$p.value, 4)
d3[l1, l2-1] <- t$parameter
count = count+1
}
}
#criticalp = 0.05/count
row.names(dt) <- var.names
colnames(dt) <- var.names[2:length(var.names)]
row.names(d2) <- var.names
colnames(d2) <- var.names[2:length(var.names)]
row.names(d3) <- var.names
colnames(d3) <- var.names[2:length(var.names)]
output <- list('tval' = dt, 'CI' = d1, 'p values' = d2, 'df' = d3)
return(output)
#ifelse(output == 1, return(dt), ifelse(output==2, return(d2), return(d3)))
}
b1_follow <- pairedttable(d3, colnames(d3[2:5]))
View(b1_follow)
b1_follow <- pairedttable(d3, colnames(d3[2:5]))
# data is a data frame in wide format with only an ID column in front of columns of interest
# var.names is a vector with the names of the columns you want to compare
# output is your desired output
dt <- matrix(nrow = length(var.names), ncol = length(var.names)-1)
pairedttable <- function(data, var.names){
# data is a data frame in wide format with only an ID column in front of columns of interest
# var.names is a vector with the names of the columns you want to compare
# output is your desired output
dt <- matrix(nrow = length(var.names), ncol = length(var.names)-1)
d1 <- matrix(nrow = length(var.names), ncol = length(var.names)-1)
d2 <- matrix(nrow = length(var.names), ncol = length(var.names)-1)
d3 <- matrix(nrow = length(var.names), ncol = length(var.names)-1)
count = 0
for (l1 in 1:(length(var.names)-1)){
print(l1)
var1 = var.names[l1]
print(var1)
for (l2 in (l1+1):length(var.names)) {
print(l2)
var2 = var.names[l2]
print(var2)
t <- t.test(data[,l1+1], data[,l2+1], paired = TRUE, na.action=na.omit)
print(t)
dt[l1, l2-1] <- round(t$statistic,2)
d1[l1, l2-1] <- paste0('[', round(t$conf.int[1],2), ',', round(t$conf.int[2],2), ']')
d2[l1, l2-1] <- round(t$p.value, 4)
d3[l1, l2-1] <- t$parameter
count = count+1
}
}
#criticalp = 0.05/count
row.names(dt) <- var.names
colnames(dt) <- var.names[2:length(var.names)]
row.names(d2) <- var.names
colnames(d2) <- var.names[2:length(var.names)]
row.names(d3) <- var.names
colnames(d3) <- var.names[2:length(var.names)]
output <- list('tval' = dt, 'CI' = d1, 'p values' = d2, 'df' = d3)
return(output)
#ifelse(output == 1, return(dt), ifelse(output==2, return(d2), return(d3)))
}
b1_follow <- pairedttable(d3, colnames(d3[2:5]))
# data is a data frame in wide format with only an ID column in front of columns of interest
# var.names is a vector with the names of the columns you want to compare
# output is your desired output
dt <- matrix(nrow = length(var.names), ncol = length(var.names)-1)
d1 <- matrix(nrow = length(var.names), ncol = length(var.names)-1)
d2 <- matrix(nrow = length(var.names), ncol = length(var.names)-1)
d3 <- matrix(nrow = length(var.names), ncol = length(var.names)-1)
count = 0
for (l1 in 1:(length(var.names)-1)){
print(l1)
var1 = var.names[l1]
print(var1)
for (l2 in (l1+1):length(var.names)) {
print(l2)
var2 = var.names[l2]
print(var2)
t <- t.test(data[,l1+1], data[,l2+1], paired = TRUE, na.action=na.omit)
print(t)
dt[l1, l2-1] <- round(t$statistic,2)
d1[l1, l2-1] <- paste0('[', round(t$conf.int[1],2), ',', round(t$conf.int[2],2), ']')
d2[l1, l2-1] <- round(t$p.value, 4)
d3[l1, l2-1] <- t$parameter
count = count+1
}
}
#criticalp = 0.05/count
row.names(dt) <- var.names
colnames(dt) <- var.names[2:length(var.names)]
row.names(d1) <- var.names
colnames(d1) <- var.names[2:length(var.names)]
row.names(d2) <- var.names
colnames(d2) <- var.names[2:length(var.names)]
row.names(d3) <- var.names
colnames(d3) <- var.names[2:length(var.names)]
View(dt)
View(d1)
View(d2)
View(d3)
output <- list('tval' = dt, 'CI' = d1, 'p values' = d2, 'df' = d3)
View(output)
b1_follow <- pairedttable(d3, colnames(d3[2:5]))
# run models on skew data
# 7.15.19 KLS updated 10.17.19
# add follow-up t-tests 2.10.20 KLS
# load required packages
library(here)
library(lme4)
library(gdata)
library(tidyr)
# load source functions
source(here::here('scr', 'isolate_skew.R'))
source(here::here('scr', 'clean_skew.R'))
source(here::here('scr', 'SummarySE.R'))
source(here::here('scr', 'pairedttable.R'))
# set hard-coded variables
# load data
dt <- read.csv(here::here("data", "bound_skew1_data.csv"))
# separate skew
d0 <- isolate_skew(dt,c(1,2),10:69)
d1 <- clean_skew(d0)
# recode response to acceptance
d1$accept <- d1$response - 1
# reorder deg_skew factor
d1$deg_skew <- factor(d1$deg_skew, levels = c('Symmetric', 'Weak', 'Moderate', 'Strong'))
# reorder valence factor
d1$valence <- factor(d1$valence, levels = c('neutral', 'gain', 'loss'))
# make magnitude a factor
d1$magnitude <- factor(d1$magnitude, levels = c('0', '0.5', '5'))
# scale and center age
d1$Age <- scale(d1$Age)
# make interaction term
d1$magval <- interaction(d1$valence, d1$magnitude)
d1$magval <- drop.levels(d1$magval)
d1$magval <- factor(d1$magval, levels = c('neutral.0', 'loss.5', 'loss.0.5', 'gain.0.5', 'gain.5'))
# baseline - only degree of skew
b1 <- glmer(accept ~ deg_skew + (1 + Age | ID), data = d1, family = binomial(link = logit), nAGQ = 1,
control=glmerControl(optimizer='bobyqa'))
summary(b1, correlation = FALSE)
## boundary fit - remove age from random effects
b1.1 <- glmer(accept ~ deg_skew + (1 | ID), data = d1, family = binomial(link = logit), nAGQ = 1,
control=glmerControl(optimizer='bobyqa'))
summary(b1.1, correlation = FALSE)
saveRDS(b1.1, here::here('output', 'baseline.RDS'))
##follow-up t-tests
d2 <- summarySE(d1, 'accept', groupvars = c('ID', 'deg_skew'))
d3 <- spread(d2[,c(1,2,4)], 'deg_skew', 'accept')
b1_follow <- pairedttable(d3, colnames(d3[2:5]))
View(b1_follow)
install.packages(rlist)
install.packages('rlist')
library(rlist)
#write.csv(b1_follow, here::here('output', 'b1_follow.csv'))
list.save(b1_follow, here::here('ouptut', 'b1_follow.rds'))
#write.csv(b1_follow, here::here('output', 'b1_follow.csv'))
list.save(b1_follow, here::here('ouptut', 'b1_follow.rds'))
#write.csv(b1_follow, here::here('output', 'b1_follow.csv'))
list.save(b1_follow, here::here('ouptut', 'b1_follow.rdata'))
#write.csv(b1_follow, here::here('output', 'b1_follow.csv'))
list.save(b1_follow, here::here('output', 'b1_follow.rds'))
source('~/github/boundSkew1/03_model_skew.R', echo=TRUE)
# load required packages
library(here)
library(lme4)
library(gdata)
library(tidyr)
library(rlist)
# load source functions
source(here::here('scr', 'isolate_skew.R'))
source(here::here('scr', 'clean_skew.R'))
source(here::here('scr', 'SummarySE.R'))
source(here::here('scr', 'pairedttable.R'))
# load data
dt <- read.csv(here::here("data", "bound_skew1_data.csv"))
# separate skew
d0 <- isolate_skew(dt,c(1,2),10:69)
d1 <- clean_skew(d0)
# recode response to acceptance
d1$accept <- d1$response - 1
# reorder deg_skew factor
d1$deg_skew <- factor(d1$deg_skew, levels = c('Symmetric', 'Weak', 'Moderate', 'Strong'))
# reorder valence factor
d1$valence <- factor(d1$valence, levels = c('neutral', 'gain', 'loss'))
# make magnitude a factor
d1$magnitude <- factor(d1$magnitude, levels = c('0', '0.5', '5'))
View(pairedttable)
View(pairedttable)
# scale and center age
d1$Age <- scale(d1$Age)
# make interaction term
d1$magval <- interaction(d1$valence, d1$magnitude)
d1$magval <- drop.levels(d1$magval)
# make interaction term
d1$magval <- interaction(d1$valence, d1$magnitude)
d1$magval <- drop.levels(d1$magval)
d1$magval <- factor(d1$magval, levels = c('neutral.0', 'loss.5', 'loss.0.5', 'gain.0.5', 'gain.5'))
# baseline - only degree of skew
b1 <- glmer(accept ~ deg_skew + (1 + Age | ID), data = d1, family = binomial(link = logit), nAGQ = 1,
control=glmerControl(optimizer='bobyqa'))
summary(b1, correlation = FALSE)
## boundary fit - remove age from random effects
b1.1 <- glmer(accept ~ deg_skew + (1 | ID), data = d1, family = binomial(link = logit), nAGQ = 1,
control=glmerControl(optimizer='bobyqa'))
summary(b1.1, correlation = FALSE)
saveRDS(b1.1, here::here('output', 'baseline.RDS'))
##follow-up t-tests
d2 <- summarySE(d1, 'accept', groupvars = c('ID', 'deg_skew'))
d3 <- spread(d2[,c(1,2,4)], 'deg_skew', 'accept')
b1_follow <- pairedttable(d3, colnames(d3[2:5]))
list.save(b1_follow, here::here('output', 'b1_follow.rds'))
rm(d2,d3, b1_follow)
# model 1 - add valence
m1 <- glmer(accept ~ deg_skew * valence + (1 | ID), data = d1, family = binomial(link = logit), nAGQ = 1,
control=glmerControl(optimizer='bobyqa'))
summary(m1, correlation = FALSE)
saveRDS(m1, here::here('output', 'm1.RDS'))
## compare model 1 and model 2
anova(b1.1,m1)
## follow-up t-tests
d4 <- summarySE(d1, 'accept', groupvars = c('ID', 'deg_skew', 'valence'))
d4$skew_valence <- interaction(d4$deg_skew, d4$valence)
d5 <- spread(d4[,c(1,9,5)], 'skew_valence', 'accept')
View(d5)
m1_follow_neutral <- pairedttable(d5, colnames(d5[2:5]), 1)
m1_follow_neutral <- pairedttable(d5, colnames(d5[2:5]))
m1_follow_gain <- pairedttable(d5, colnames(d5[6:9]))
m1_follow_loss <- pairedttable(d5, colnames(d5[10:13]))
list.save(m1_follow_neutral, here::here('output', 'm1_follow_neutral.rds'))
list.save(m1_follow_gain, here::here('output', 'm1_follow_gain.rds'))
list.save(m1_follow_loss, here::here('output', 'm1_follow_loss.rds'))
rm(d4, d5, m1_follow_neutral, m1_follow_gain, m1_follow_loss)
source('~/github/boundSkew1/03_model_skew.R', echo=TRUE)
saveRDS(m2, here::here('output', 'm2.RDS'))
source('~/github/boundSkew1/03_model_skew.R', echo=TRUE)
library(here)
library(lme4)
library(gdata)
library(tidyr)
library(rlist)
# load source functions
source(here::here('scr', 'isolate_skew.R'))
source(here::here('scr', 'clean_skew.R'))
source(here::here('scr', 'SummarySE.R'))
source(here::here('scr', 'pairedttable.R'))
# set hard-coded variables
# load data
dt <- read.csv(here::here("data", "bound_skew1_data.csv"))
# separate skew
d0 <- isolate_skew(dt,c(1,2),10:69)
d1 <- clean_skew(d0)
# recode response to acceptance
d1$accept <- d1$response - 1
# reorder deg_skew factor
d1$deg_skew <- factor(d1$deg_skew, levels = c('Symmetric', 'Weak', 'Moderate', 'Strong'))
# reorder valence factor
d1$valence <- factor(d1$valence, levels = c('neutral', 'gain', 'loss'))
# make magnitude a factor
d1$magnitude <- factor(d1$magnitude, levels = c('0', '0.5', '5'))
# scale and center age
d1$Age <- scale(d1$Age)
# make interaction term
d1$magval <- interaction(d1$valence, d1$magnitude)
d1$magval <- drop.levels(d1$magval)
d1$magval <- factor(d1$magval, levels = c('neutral.0', 'loss.5', 'loss.0.5', 'gain.0.5', 'gain.5'))
## Follow-up t-tests
d6 <- summarySE(d1, 'accept', groupvars = c('ID', 'deg_skew', 'magnitude'))
d6$skew_mag <- interaction(d6$deg_skew, d6$magnitude)
d7 <- spread(d6[,c(1,9,5)], 'skew_mag', 'accept')
m2_follow_neutral <- pairedttable(d7, colnames(d7[2:5]))
m2_follow_gain <- pairedttable(d7, colnames(d7[6:9]))
m2_follow_zero <- pairedttable(d7, colnames(d7[2:5]))
m2_follow_small <- pairedttable(d7, colnames(d7[6:9]))
m2_follow_large <- pairedttable(d7, colnames(d7[10:13]))
list.save(m2_follow_zero, here::here('output', 'm2_follow_zero.rds'))
list.save(m2_follow_small, here::here('output', 'm2_follow_smallmag.rds'))
list.save(m2_follow_large, here::here('output', 'm2_follow_largemag.rds'))
rm(d6, d7, m2_follow_zero, m2_follow_small, m2_follow_large)
View(m2_follow_gain)
## Follow-up t-tests
d6 <- summarySE(d1, 'accept', groupvars = c('ID', 'deg_skew', 'magnitude'))
View(d6)
d6$skew_mag <- interaction(d6$deg_skew, d6$magnitude)
d7 <- spread(d6[,c(1,9,5)], 'skew_mag', 'accept')
m2_follow_zero <- pairedttable(d7, colnames(d7[2:5]))
m2_follow_small <- pairedttable(d7, colnames(d7[6:9]))
m2_follow_large <- pairedttable(d7, colnames(d7[10:13]))
source('~/github/boundSkew1/03_model_skew.R', echo=TRUE)
b1_follow <- readRDS("~/github/boundSkew1/output/b1_follow.rds")
b1_follow$tval
m1_follow_loss <- readRDS("~/github/boundSkew1/output/m1_follow_loss.rds")
m1_follow_loss$tval
m2_follow_largemag <- readRDS("~/github/boundSkew1/output/m2_follow_largemag.rds")
m2_follow_largemag$tval
View(pairedttable)
View(pairedttable)
m2_follow_smallmag$tval
m2_follow_smallmag <- readRDS("~/github/boundSkew1/output/m2_follow_smallmag.rds")
m2_follow_smallmag$tval
View(pairedttable)
## Follow-up t-tests
d6 <- summarySE(d1, 'accept', groupvars = c('ID', 'deg_skew', 'magnitude'))
d6$skew_mag <- interaction(d6$deg_skew, d6$magnitude)
d7 <- spread(d6[,c(1,9,5)], 'skew_mag', 'accept')
View(d7)
View(d7)
colMeans(d7)
colMeans(d7, na.rm=T)
m2_follow_zero <- pairedttable(d7, colnames(d7[2:5]))
m2_follow_zero
m2_follow_small <- pairedttable(d7, colnames(d7[6:9]))
m2_follow_zero <- pairedttable(d7[c(1,2:5)], colnames(d7[2:5]))
m2_follow_small <- pairedttable(d7[c(1,6:9)], colnames(d7[6:9]))
m2_follow_small
## Follow-up t-tests
d6 <- summarySE(d1, 'accept', groupvars = c('ID', 'deg_skew', 'magnitude'))
d6$skew_mag <- interaction(d6$deg_skew, d6$magnitude)
d7 <- spread(d6[,c(1,9,5)], 'skew_mag', 'accept')
m2_follow_zero <- pairedttable(d7[c(1,2:5)], colnames(d7[2:5]))
m2_follow_small <- pairedttable(d7[c(1,6:9)], colnames(d7[6:9]))
m2_follow_large <- pairedttable(d7[[c(1,10:13)]], colnames(d7[10:13]))
list.save(m2_follow_zero, here::here('output', 'm2_follow_zero.rds'))
list.save(m2_follow_small, here::here('output', 'm2_follow_smallmag.rds'))
list.save(m2_follow_large, here::here('output', 'm2_follow_largemag.rds'))
rm(d6, d7, m2_follow_zero, m2_follow_small, m2_follow_large)
m1_follow_neutral <- pairedttable(d5[c(1,2:5)], colnames(d5[2:5]))
m1_follow_gain <- pairedttable(d5[c(1,6:9)], colnames(d5[6:9]))
m1_follow_loss <- pairedttable(d5[c(1,10:13)], colnames(d5[10:13]))
list.save(m1_follow_neutral, here::here('output', 'm1_follow_neutral.rds'))
list.save(m1_follow_gain, here::here('output', 'm1_follow_gain.rds'))
list.save(m1_follow_loss, here::here('output', 'm1_follow_loss.rds'))
rm(d4, d5, m1_follow_neutral, m1_follow_gain, m1_follow_loss)
m1_follow_neutral <- pairedttable(d5[c(1,2:5)], colnames(d5[2:5]))
## follow-up t-tests
d4 <- summarySE(d1, 'accept', groupvars = c('ID', 'deg_skew', 'valence'))
d4$skew_valence <- interaction(d4$deg_skew, d4$valence)
d5 <- spread(d4[,c(1,9,5)], 'skew_valence', 'accept')
m1_follow_neutral <- pairedttable(d5[c(1,2:5)], colnames(d5[2:5]))
m1_follow_gain <- pairedttable(d5[c(1,6:9)], colnames(d5[6:9]))
m1_follow_loss <- pairedttable(d5[c(1,10:13)], colnames(d5[10:13]))
list.save(m1_follow_neutral, here::here('output', 'm1_follow_neutral.rds'))
list.save(m1_follow_gain, here::here('output', 'm1_follow_gain.rds'))
list.save(m1_follow_loss, here::here('output', 'm1_follow_loss.rds'))
rm(d4, d5, m1_follow_neutral, m1_follow_gain, m1_follow_loss)
## Follow-up t-tests
d6 <- summarySE(d1, 'accept', groupvars = c('ID', 'deg_skew', 'magnitude'))
d6$skew_mag <- interaction(d6$deg_skew, d6$magnitude)
d7 <- spread(d6[,c(1,9,5)], 'skew_mag', 'accept')
m2_follow_zero <- pairedttable(d7[c(1,2:5)], colnames(d7[2:5]))
m2_follow_small <- pairedttable(d7[c(1,6:9)], colnames(d7[6:9]))
m2_follow_large <- pairedttable(d7[c(1,10:13)], colnames(d7[10:13]))
list.save(m2_follow_zero, here::here('output', 'm2_follow_zero.rds'))
list.save(m2_follow_small, here::here('output', 'm2_follow_smallmag.rds'))
list.save(m2_follow_large, here::here('output', 'm2_follow_largemag.rds'))
rm(d6, d7, m2_follow_zero, m2_follow_small, m2_follow_large)
source('~/github/boundSkew1/03_model_skew.R', echo=TRUE)
m3_follow_loss_5 <- readRDS("~/github/boundSkew1/output/m3_follow_loss_5.rds")
View(m3_follow_loss_5)
